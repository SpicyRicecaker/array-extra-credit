INCLUDE Irvine32.inc

.data
    ARR_SIZE DWORD 5
    onedarr1 DWORD 1,2,9,4,5
    onedarr2 DWORD 11,12,13,14,15
    onedarr3 DWORD 21,22,23,24,25
    twodarr1 DWORD OFFSET onedarr1, onedarr2, onedarr3
.code

; Receives array_size, array offset, 
; push in reverse order
ArrayDspl PROC
     push EBP
     mov EBP, ESP
     pushad
     mov ESI, [EBP+12] ; @list in ESI
     mov ECX, [EBP+8] ; Count in ECX
     prtNum:
          mov EAX, [ESI]
          call WriteDec
          call Crlf
          add ESI, 4 ; May be different, Why?
          loop  prtNum
     popad
     pop EBP
     ret 8
ArrayDspl ENDP

; A[y][x]
; Receives: array offset, array size y, array size x, index x, index y (optional)
; Return: in the address of array offset
ARRAY_OFFSET EQU [EBP+8]
ARRAY_SIZE_Y EQU [EBP+12]
ARRAY_SIZE_X EQU [EBP+16]
ARRAY_X EQU [EBP+20]
ARRAY_Y EQU [EBP+24]
procArrGet proc
    push EBP
    mov EBP, ESP
    pushad

    mov EAX, ARRAY_SIZE_Y
    cmp EAX, 1
    je one_dimensional

    two_dimensional:
        jmp cleanup

    one_dimensional:
        mov ESI, ARRAY_OFFSET

        mov EAX, ARRAY_X
        mov ECX, 4
        mul ECX

        mov EDX, [ESI+EAX]

        mov [EBP+8], EDX
    cleanup:
        popad
        pop EBP
        ret 16
procArrGet endp

; Receives: y, x
; Return: VOID
procArrStr proc
; prologue
Push ebp
Mov ebp, esp

Pushad ;Pushing all registers in

Popad ;popping registers

; epilogue
Pop esp
procArrStr endp

Main proc
    ; index y (omitted)
    ; index x
    push 4
    ; array x
    push ARR_SIZE
    ; array y 
    push 1
    push OFFSET onedarr1
    call procArrGet

    pop EAX
    call WriteDec

    invoke exitprocess,0
Main endp
End main
